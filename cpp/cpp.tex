\documentclass{programmingnotes}
\begin{document}
\renewcommand{\footrulewidth}{0.4pt}
\fancyhead[LE,LO]{C++ -- cheat sheet (page \thepage/\pageref{LastPage})}
\fancyhead[RO,RE]{source: --} 
\fancyfoot[RF]{author: Remigiusz Suwalski, date: \today}
%\fancyfoot[LF]{}
\begin{multicols*}{3}

Header files: \texttt{*.h}.

\mintinline{cpp}{#include}, \mintinline{cpp}{#define}, \mintinline{cpp}{#ifdef}, \mintinline{cpp}{#ifndef}, \mintinline{cpp}{#endif}, \mintinline{cpp}{#undef} are preprocessor directives.

Namespaces.

Input and output.

\section{Data types}
\begin{enumerate}
\item Boolean: \texttt{bool}, 
\item Character: \texttt{char}, 
\item Integer: \texttt{int}, 
\item Floating point: \texttt{float}, 
\item Double floating point: \texttt{double}, 
\item Valueless: \texttt{void}, 
\item Wide character: \texttt{wchar\_t}.
\end{enumerate}

\section{Conditionals}
The syntactic sugar
\begin{minted}{c++}
condition ? value_true : value_false
\end{minted}
is a replacement for classical conditional instruction:
\begin{minted}{c++}
if (condition) {
  commands;
} else {
  commands;
}
\end{minted}

There is also a switch-case instruction driven by a key of enum type:
\begin{minted}{c++}
switch (key) {
  case value1: instructions; break;
  case value2: instructions; break;
  default: instructions;
}
\end{minted}

Loops:
\begin{minted}{c++}
for (init, test, action) {
  commands
}
\end{minted}

\begin{minted}{c++}
for (variable : table) {
  // available in C++ 11
  commands
}
\end{minted}

\begin{minted}{c++}
while (conditions) {
  commands
}
\end{minted}

\begin{minted}{c++}
do {
  commands
} while (conditions)
\end{minted}

There are two useful instructions: \mintinline{cpp}{continue} jumps to the end of loop's body, \mintinline{cpp}{break} jumps out of the loop.

\section{Functions}
\begin{minted}{c++}
type function(type arg, type arg, ...) {
  commands
}
\end{minted}

\end{multicols*}
\end{document}